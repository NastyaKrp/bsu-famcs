# Порядок перемножения матриц
Дана последовательность из s матриц A1, A2, …, As. Требуется определить, в каком порядке их следует перемножать, чтобы число атомарных операций умножения было минимальным. Матрицы предполагаются совместимыми по отношению к матричному умножению (т. е. число столбцов матрицы Ai − 1 совпадает с числом строк матрицы Ai).

Будем считать, что произведение матриц — операция, которая принимает на вход две матрицы размера k × m и m × n и возвращает матрицу размера k × n, затратив на это kmn атомарных операций умножения. (Базовый тип позволяет хранить любой элемент итоговой и любой возможной промежуточной матрицы, поэтому умножение двух элементов требует одной атомарной операции.)

Так как перемножение матриц ассоциативно, итоговая матрица не зависит от порядка выполнения операций умножения. Другими словами, нет разницы, в каком порядке расставляются скобки между множителями, результат будет один и тот же.

**Формат входных данных**

В первой строке задано число s матриц (2 ≤ s ≤ 100). В последующих s строках заданы размеры матриц: строка i + 1 содержит через пробел число n[i] строк и число m[i] столбцов матрицы Ai (1 ≤ n[i], m[i] ≤ 100). Гарантируется, что m[i] совпадает с n[i + 1] для всех индексов i от 1 до s − 1.

**Формат выходных данных**

Выведите минимальное число атомарных операций умножения, необходимое для перемножения s матриц.

**Пример**

input.txt

3
2 3
3 5
5 10

output.txt

130

```
#include <fstream>
#include <climits>
using namespace std;

int sol(int* arr, int a)
{
	int n = a;
	int** matr = new int*[n];
	for (int i = 0; i < n; i++)
	{
		matr[i] = new int[n];
	}

	for (int i = 1; i < n; i++)
	{
		for (int j = 1; j < n; j++)
		{
			matr[i][j] = 0;
		}
	}

	for (int l = 2; l < n; l++)
	{
		for (int i = 1; i < n - l + 1; i++)
		{
			int j = l + i - 1;
			matr[i][j] = INT_MAX;
			for (int k = i; k < j; k++)
			{
				int tmp = matr[i][k] + matr[k + 1][j] + arr[i - 1] * arr[k] * arr[j];
				if (tmp < matr[i][j])
				{
					matr[i][j] = tmp;
				}
			}
		}
	}
	return matr[1][n - 1];
}

int main()
{
	ifstream in("input.txt");
	ofstream fout("output.txt");
	int count;
	in >> count;
	int* nm = new int[count + 1];
	int k = 2;
	in >> nm[0];
	in >> nm[1];
	for (int i = 2; i < count * 2; i++)
	{
		if (i % 2 == 1)
		{
			in >> nm[i / 2 + 1];
		}
		else
		{ 
			int tmp;
			in >> tmp;
		}
	}
	fout << sol(nm, count + 1);
	return 0;
}
```
