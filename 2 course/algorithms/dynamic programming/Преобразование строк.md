# Преобразование строк

На вход подаются две символьные последовательности A и B, каждая последовательность состоит из маленьких латинских букв и имеет длину не более 1000 символов. Необходимо преобразовать последовательность A в последовательность B с минимальным суммарным штрафом, который определяется следующим образом:

* удаление символа из строки A равно x баллов;
* вставка символа в строку A равна y баллов;
* замена символа в строке A на любой другой равна z баллов.

**Формат входных данных**

В первой строке находится число x. Во второй строке — число y. В третьей строке — число z. В следующих двух строках находятся символьные последовательности A и B (тип элементов последовательности string).

**Формат выходных данных**

Выведите минимальный суммарный штраф.

**Пример**

in.txt

2

3

1

abcd

bce

out.txt

3

```
#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
using namespace std;

int main()
{
	ofstream fout("out.txt");
	ifstream in("in.txt");
	int x, y, z;
	in >> x >> y >> z;
	string s1, s2;
	in >> s1 >> s2;
	int n = s2.length();
	int m = s1.length();
	int** matr = new int* [m + 1];
	for (int i = 0; i < m + 1; i++)
	{
		matr[i] = new int[n + 1];
	}
	for (int i = 0; i <= m; i++)
	{
		matr[i][0] = x * i;
	}
	for (int i = 0; i <= n; i++)
	{
		matr[0][i] = y * i;
	}
	for (int i = 1; i <= m; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			int coef;
			if (s2[j - 1] != s1[i - 1])
			{
				coef = 1;
			}
			else
			{
				coef = 0;
			}
			matr[i][j] = min(matr[i - 1][j] + x, matr[i][j - 1] + y);
			matr[i][j] = min(matr[i][j], matr[i - 1][j - 1] + coef * z);
		}
	}
	fout << matr[m][n];
}
```
